# inception-of-Things
This project aims to introduce you to Kubernetes from a developer's perspective. You will have to set up small clusters and discover the mechanics of continuous integration. At the end of this project, will be able to set up a working cluster in Docker and have a usable continuous integration pipeline for applications.


# Before start

## What is Kubernetes? (K8s)
- a powerful system for managing multiple containers across many computers. It's like an operating system for a cluster of computers. Its main jobs are:
    
    - Automation (Orchestration): It automates deploying, scaling, and managing your applications. If an application crashes, Kubernetes automatically restarts it. If traffic increases, it can automatically add more containers.

    - Resource Management: It treats a group of computers (a cluster) as one giant resource pool of CPU and memory, and it intelligently decides where to run your applications.

#### How to control Kubernetes? — kubectl
- `kubectl` is the official command-line tool (CLI) for communicating with a Kubernetes cluster. Think of it as the universal remote control for your cluster.

- It allows you to tell the cluster what to do—from deploying applications to checking their status. You send commands to the cluster's "brain" (the Master Node's API Server), and it carries out the work.


**Common `kubectl` commands**
- `kubectl get`: To view resources. For example, `kubectl get nodes` shows all the computers in your cluster, and kubectl get pods shows all your running applications.

- `kubectl apply`: To create or update resources from a configuration file. You will use this command extensively in Part 2 to launch your applications.

- `kubectl describe`: To get detailed information about a specific resource, which is very useful for troubleshooting.

- `kubectl logs`: To view the logs generated by an application, helping you debug issues.

- `kubectl delete`: To remove resources from the cluster.



## What is K3s?
- a lightweight, certified version of Kubernetes. The creators took the full, complex Kubernetes and removed non-essential parts to make it much smaller, faster, and easier to install and use, especially for smaller environments like the one in this project.

    ### A K3s Cluster:
    - A K3s Cluster is a group of computers (nodes) that are managed by the K3s program. It has two main types of nodes, just like the ones in this project:

        - Master / Control-Plane Node (jischoiS): This is the "brain" or the "manager" of the cluster. It makes all the decisions: where to run applications, how to respond to failures, and it keeps track of the state of the entire system. In this setup, this is the controller mode machine.

        - Worker / Agent Node (jischoiSW): These are the "muscles" of the cluster. They do the actual work of running the applications (containers) as instructed by the master node. In this setup, this is the agent mode machine.

## What is Vagrant?
- a tool for building and managing virtual machine environments in a single, automated workflow.

> Imagine you have a detailed blueprint for building a custom computer. This blueprint specifies everything: the exact parts to use, the operating system to install, the network configuration, and which software to set up after it first boots.

Vagrant works just like that:

- The Blueprint: The `Vagrantfile` is that blueprint. It's a single file, in code, everything needed for your virtual environment. You specified the OS, the IP addresses, and the shell scripts to install K3s.

- The Automated Builder: When you run the `vagrant up` command in terminal, Vagrant acts as an automated builder. It reads your blueprint (`Vagrantfile`) and instructs a virtualization program like VirtualBox to build the machines exactly as specified.

    
#### The Key Advantages of Vagrant
    - Reproducibility (Solving the "It works on my machine" problem)
    - Consistency (The same environment, anywhere)
    - Automation & Portability (Simplicity and Convenience)

### Vagrant vs. Docker
> Both Vagrant and Docker are powerful tools designed to create consistent and reproducible environments for software development. While they share a similar goal, they achieve it in fundamentally different ways.

**Similarity**
- The primary goal for both Vagrant and Docker is to solve the classic "it works on my machine" problem. They package an application with its dependencies, ensuring that it runs the same way everywhere, regardless of the developer's local setup.

**The Key Difference**

- *Virtualization Level*: The main difference lies in what they virtualize.
    - Vagrant virtualizes an entire Operating System.
    - Docker virtualizes just the application and its dependencies.

- This is best understood with the "House vs. Apartment" analogy.

    1. Vagrant is like building a single-family house.

        > Vagrant uses a hypervisor like VirtualBox to create a complete, self-contained virtual machine (VM). This is a full-fledged computer with its own guest operating system (OS), kernel, CPU, memory, and network interfaces.

        - Complete Isolation: The house is entirely separate from its neighbors. A VM is fully isolated from the host machine and other VMs.
        - Heavy on Resources: Building a house is a major undertaking. A VM consumes significant resources, including gigabytes (GB) of disk space and a large amount of RAM. It takes several minutes to boot up.
        - Goal: The goal is to reproduce an entire system environment, including the specific operating system and its configuration.



    2. Docker is like moving into an apartment unit.

        > A Docker container does not run its own full OS. Instead, it runs as an isolated process on the host machine's OS, sharing the host's kernel.
    
        - Shared Resources: The apartment is a private space within a larger building. A container is an isolated space for your application, but it shares the building's foundation and utilities (the host OS kernel) with other containers.
        - Lightweight and Fast: Moving into an apartment is much quicker than building a house. Because a container doesn't need to boot an OS, it is extremely lightweight (often measured in megabytes, MB) and can start in seconds.
        - Goal: The goal is to isolate an individual application and only the libraries and dependencies it needs to run.


| Feature | Vagrant (Virtual Machine) | Docker (Container) |
| :--- | :--- | :--- |
| **Isolation Level** | Operating System (OS) Level | Application Level |
| **Components** | Guest OS + Libraries + Application | Libraries + Application |
| **Size** | Large (Gigabytes) | Small (Megabytes) |
| **Start-up Speed** | Slow (Minutes) | Fast (Seconds) |
| **Resource Usage** | High (Significant Memory/CPU) | Low (Shares Host OS resources efficiently) |
| **Primary Purpose** | Reproducing a full development **'Environment'** | Deploying and running a single **'Application'** |
 
----
    ```bash
    vagrant delete -f
    vagrant up
    vagrant status
    vagrant ssh jischoiS

    kubectl get nodes -o wide
    ```

